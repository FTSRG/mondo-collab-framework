/*
 * generated by Xtext
 */
package mondo.collab.security.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import mondo.collab.security.xtext.securityAccess.AccessControlModel;
import mondo.collab.security.xtext.securityAccess.Binding;
import mondo.collab.security.xtext.securityAccess.Group;
import mondo.collab.security.xtext.securityAccess.ImportResource;
import mondo.collab.security.xtext.securityAccess.ObjectBind;
import mondo.collab.security.xtext.securityAccess.Policy;
import mondo.collab.security.xtext.securityAccess.RoleBind;
import mondo.collab.security.xtext.securityAccess.Rule;
import mondo.collab.security.xtext.securityAccess.SecurityAccessPackage;
import mondo.collab.security.xtext.securityAccess.User;
import mondo.collab.security.xtext.securityAccess.ValueBind;
import mondo.collab.security.xtext.services.SecurityAccessGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SecurityAccessSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SecurityAccessGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SecurityAccessPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SecurityAccessPackage.ACCESS_CONTROL_MODEL:
				sequence_AccessControlModel(context, (AccessControlModel) semanticObject); 
				return; 
			case SecurityAccessPackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case SecurityAccessPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case SecurityAccessPackage.IMPORT_RESOURCE:
				sequence_ImportResource(context, (ImportResource) semanticObject); 
				return; 
			case SecurityAccessPackage.OBJECT_BIND:
				sequence_ObjectBind(context, (ObjectBind) semanticObject); 
				return; 
			case SecurityAccessPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case SecurityAccessPackage.ROLE_BIND:
				sequence_RoleBind(context, (RoleBind) semanticObject); 
				return; 
			case SecurityAccessPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case SecurityAccessPackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			case SecurityAccessPackage.VALUE_BIND:
				sequence_ValueBind(context, (ValueBind) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (roles+=Role* policy=Policy)
	 */
	protected void sequence_AccessControlModel(EObject context, AccessControlModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (param=[Variable|ID] value=Bind)
	 */
	protected void sequence_Binding(EObject context, Binding semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.BINDING__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.BINDING__PARAM));
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.BINDING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.BINDING__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBindingAccess().getParamVariableIDTerminalRuleCall_1_0_1(), semanticObject.getParam());
		feeder.accept(grammarAccess.getBindingAccess().getValueBindParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID users+=[User|ID]*)
	 */
	protected void sequence_Group(EObject context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importURI=STRING
	 */
	protected void sequence_ImportResource(EObject context, ImportResource semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.IMPORT_RESOURCE__IMPORT_URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.IMPORT_RESOURCE__IMPORT_URI));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportResourceAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     object=[EObject|ID]
	 */
	protected void sequence_ObjectBind(EObject context, ObjectBind semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.OBJECT_BIND__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.OBJECT_BIND__OBJECT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getObjectBindAccess().getObjectEObjectIDTerminalRuleCall_1_0_1(), semanticObject.getObject());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=ConflictResolutionTypes roles+=[Role|ID]+ imports+=ImportResource* rules+=Rule*)
	 */
	protected void sequence_Policy(EObject context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     role=[Role|ID]
	 */
	protected void sequence_RoleBind(EObject context, RoleBind semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.ROLE_BIND__ROLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.ROLE_BIND__ROLE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRoleBindAccess().getRoleRoleIDTerminalRuleCall_1_0_1(), semanticObject.getRole());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID type=RuleType rights=RuleRights pattern=[Pattern|STRING] bindings+=Binding*)
	 */
	protected void sequence_Rule(EObject context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_User(EObject context, User semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.ROLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.ROLE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getUserAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ValueBind(EObject context, ValueBind semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SecurityAccessPackage.Literals.VALUE_BIND__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SecurityAccessPackage.Literals.VALUE_BIND__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getValueBindAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
}
